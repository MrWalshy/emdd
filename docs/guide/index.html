<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EMDD | Guide</title>
    <link rel="stylesheet" href="/style.css" />
</head>
<body>
    <nav class="navbar row">
    <button id="toggle" class="hamburger ml-auto"><span></span><span></span><span></span></button>
    <div class="col-12">
        <ul class="nav-content w-60 w-md-80 w-sm-90 d-block ml-auto mr-auto">
            <li class="nav-link"><a href="/">Home</a></li>
            <li class="nav-link"><a href="/docs/guide">Usage guide</a></li>
            <li class="nav-link"><a href="/docs/api">API</a></li>
        </ul>
    </div>
</nav>
<div class="row"><div class="col-12"><main class="ml-auto mr-auto w-60 w-md-80 w-sm-90">
    <header class="bg-primary fg-light p-16">
    <h1>Usage guide</h1>
    <p>A quick-starter guide to the API and built-in apps</p>
</header><h2>Using the static site generator</h2>
<h2>Setting up a custom transpiler</h2>
<p>The API for this library is simple to use. To get started, let's create some example content:</p><pre><code># My title

@toc();

## My secondary title

Some text

@js()
```
let sum = 3 + 3;
return `&lt;p>Sum of 3 + 3 is ${sum}&lt;/p>`;
```

Inline plugins @js(value="
  let sum = 3 + 3; 
  return sum;
"); should be supported.

@docArgs()
```
"title": "Test | Title"
```

@template(name="title" args="text lead")
```
&lt;header>
    &lt;h1>@text;&lt;/h1>
    &lt;p>@lead;&lt;/p>
&lt;/header>
```

@weave(name="title")
```
"text": "Hello world",
"lead": "Some leading text"
```

@weave(name="title" text="Hello world 2" lead="Some more lead");

@template(name="data" args="username")
```
&lt;li>@username;&lt;/li>
```

@js(name="dataSource" defer="true" value="return [{ username: 'bob' }, { username: 'sarah' }, { username: 'fred' }];");

&lt;ul>
@weave(name="data" argsSource="dataSource");
&lt;/ul>
`;
</code></pre><p>Now, we need a tokeniser. This will split the source string into an array of <code>Token</code>s, each representing some specific, or non-specific, character type:</p>
<pre><code class="language-js">const tokeniser = new Tokeniser(emdd, ["js", "docArgs", "template", "weave", "toc"]);
const tokens = tokeniser.tokenise();
</code></pre>
<p>We pass the identifiers of the content processors and post-processors to the tokenisers constructor, these are keywords that the tokeniser should recognise as an identifier if following an <code>@</code> symbol.</p>
<ul>
  <li>The <code>js</code> plugin will run JavaScript code during the build process</li>
  <li><code>docArgs</code> is a built-in plugin which is activated when this keyword is supplied to the tokeniser</li>
  <li>The <code>template</code> and <code>weave</code> plugins come packaged together, these are used for creating templates and weaving them into a document</li>
  <li>The <code>toc</code> plugin is a post-processor which will generate a table of contents at its location, we can also use the <code>exclude</code> parameter to specify which HTML element types to exclude. For example, we could pass <code>exclude="h1 h2"</code> to exclude <code>&#x3C;h1></code> and <code>&#x3C;h2></code> elements.</li>
</ul>
<p>Once we have the tokens, we can parse them into <code>Block</code>'s:</p>
<pre><code class="language-js">const parser = new Parser(tokens);
const blocks = parser.parse();
</code></pre>
<p>The parser accepts a sequence of tokens upon instantiation, and produces an array of blocks representing the document when its <code>parse()</code> method is called.</p>
<p>Let's now setup the plugins, ready for transpilation. As we want the <code>weave</code> blocks to be able to call functions defined in a <code>js</code> block as a data source, we pass a context object to both which ties them together:</p>
<pre><code class="language-js">let processorContext = {};
let contentProcessors = [new WeaveProcessor(context), new JSProcessor(context)];
</code></pre>
<p>The table of contents, <code>toc</code>, processor is a post processor. Let's create that now:</p>
<pre><code class="language-js">const postProcessors = [new HtmlTocPostProcessor()];
</code></pre>
<p>We also want a document transformer, in this case to produce a HTML5 document:</p>
<pre><code class="language-js">const htmlDocumentTransformer = new HtmlDocumentProcessor();
</code></pre>
<p>We can then create a new <code>Transpiler</code>, passing it the content and post-processing plugins:</p>
<pre><code class="language-js">const transpiler = new Transpiler(contentProcessors, postProcessors);
</code></pre>
<p>We can then transpile the content to its target:</p>
<pre><code class="language-js">const output = transpiler.transpile(blocks, htmlDocumentTransformer);
</code></pre>
<p>The document processor is passed to the <code>transpile</code> method, this allows you to produce different document types dependending on your needs.</p>
<h2>Writing documents</h2>
<h3>Markdown</h3>
<h3>Extensions</h3>
    <footer class="bg-primary fg-light p-16">
    <small>Extensible Markdown (.emdd) - &copy; 2023</small>
    <br />
    <small>This site was generated by .emdd</small>
</footer>
</main></div></div>
    
</body>
</html>
